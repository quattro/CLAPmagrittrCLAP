---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/"
)
library(CLAPmagrittrCLAP)
```

# CLAPmagrittrCLAP <img src="man/figures/logo.png" align="right" />


## Overview

The CLAPmagrittrCLAP package offers a set of operators which make your code more
readable by:

* structuring sequences of data operations left-to-right (as opposed to
  from the inside and out),
* avoiding nested function calls,
* minimizing the need for local variables and function definitions, and
* making it easy to add steps anywhere in the sequence of operations.

The operators pipe their left-hand side values forward into expressions that
appear on the right-hand side, i.e. one can replace `f(x)` with
`x %ğŸ‘% f()`, where `%ğŸ‘%` is the (main) pipe-operator. When coupling
several function calls with the pipe-operator, the benefit will become
more apparent. Consider this pseudo example:

```{r, eval = FALSE}
the_data <-
  read.csv('/path/to/data/file.csv') %ğŸ‘%
  subset(variable_a > x) %ğŸ‘%
  transform(variable_c = variable_a/variable_b) %ğŸ‘%
  head(100)
```

Four operations are performed to arrive at the desired data set, and they
are written in a natural order: the same as the order of execution. Also, no
temporary variables are needed. If yet another operation is required, it is
straight-forward to add to the sequence of operations wherever it may be needed.

If you are new to CLAPmagrittrCLAP, the best place to start is the
[pipes chapter](http://r4ds.had.co.nz/pipes.html) in R for data science.

## Installation

```{r, eval = FALSE}
# install.packages("devtools")
devtools::install_github("quattro/CLAPmagrittrCLAP")
```

## Usage

### Basic piping

* `x %ğŸ‘% f` is equivalent to `f(x)`
* `x %ğŸ‘% f(y)` is equivalent to `f(x, y)`
* `x %ğŸ‘% f %ğŸ‘% g %ğŸ‘% h` is equivalent to `h(g(f(x)))`

Here, "equivalent" is not technically exact: evaluation is non-standard,
and the left-hand side is evaluated before passed on to the right-hand side
expression. However, in most cases this has no practical implication.

### The argument placeholder

* `x %ğŸ‘% f(y, .)` is equivalent to `f(y, x)`
* `x %ğŸ‘% f(y, z = .)` is equivalent to `f(y, z = x)`

### Re-using the placeholder for attributes

It is straight-forward to use the placeholder several times
in a right-hand side expression. However, when the placeholder
only appears in a nested expressions CLAPmagrittrCLAP will still apply
the first-argument rule. The reason is that in most cases this
results more clean code.

`x %ğŸ‘% f(y = nrow(.), z = ncol(.))` is equivalent to
   `f(x, y = nrow(x), z = ncol(x))`

The behavior can be
overruled by enclosing the right-hand side in braces:

`x %ğŸ‘% {f(y = nrow(.), z = ncol(.))}` is equivalent to
   `f(y = nrow(x), z = ncol(x))`

### Building (unary) functions

Any pipeline starting with the `.` will return a function which can later
be used to apply the pipeline to values. Building functions in CLAPmagrittrCLAP
is therefore similar to building other values.

```{r}
f <- . %ğŸ‘% cos %ğŸ‘% sin
# is equivalent to
f <- function(.) sin(cos(.))
```

### Pipe with exposition of variables

Many functions accept a data argument, e.g. `lm` and `aggregate`, which
is very useful in a pipeline where data is first processed and then passed
into such a function. There are also functions that do not have a data
argument, for which it is useful to expose the variables in the data.
This is done with the `%ğŸ‘Œ%` operator:

```{r exposition}
iris %ğŸ‘%
  subset(Sepal.Length > mean(Sepal.Length)) %ğŸ‘Œ%
  cor(Sepal.Length, Sepal.Width)

data.frame(z = rnorm(100)) %ğŸ‘Œ%
  ts.plot(z)
```

### Compound assignment pipe operations

There is also a pipe operator which can be used as shorthand notation
in situations where the left-hand side is being "overwritten":

```{r, eval = FALSE}
iris$Sepal.Length <-
  iris$Sepal.Length %ğŸ‘%
  sqrt()
```

To avoid the repetition of the left-hand side immediately after the assignment
operator, use the `%ğŸ™Œ%` operator:

```{r}
iris$Sepal.Length %ğŸ™Œ% sqrt
```

This operator works exactly like `%ğŸ‘%`, except the pipeline assigns the result
rather than returning it. It must be the first pipe operator in a longer chain.
